/*:
[Содержание](Table%20of%20contents) • [Предыдущая страница](@previous) • [Следующая страница](@next)
 
## One-sided ranges

[SE-0172][SE-0172] представляет новый протокол `RangeExpression` и множество prefix/postfix операторов для формирования односторонних диапазонов, то есть диапазонов, где либо верхняя, либо нижняя граница неопределены.
 
 [SE-0172]: https://github.com/apple/swift-evolution/blob/master/proposals/0172-one-sided-ranges.md "Swift Evolution Proposal SE-0172: One-sided Ranges"
 
 В односторонних диапазонах "пустая" сторона означает минимальное или максимальное значение в зависимости от контекста.
 
 В случае подписки (subscripting) в контейнерах это означает, что вы можете не указывать такие вещи, как `string.endIndex` или `array.count`.
 Например, если вы хотите разделить массив на две половинки:
 
 */

 let array = [1,2,3,4,5,6,7,8,9,10]
 let middle = array.count / 2
 let firstHalf = array[..<middle]
 let secondHalf = array[middle...]

/*:
  если вы хотите получить подстроку до какого-то индекса:
*/
let string = "Каждый охотник желает знать, где сидит фазан."
let index = string.index(of: "е")!
string[..<index]
/*:
 или получить подстроку после какого-то индекса:
*/

string[index...]
/*:
 Для односторонних диапазонов до какой-то заданной величины вы можете использовать ..< для исключающего диапазона или ... для включающего диапазона точно также, как и для двусторонних диапазонов. Для одностороннего диапазона, начинающегося с заданного значения, разрешен только ... , так как нет никакой разницы между ... и ..<.
 */

let openFirstHalf = array[..<middle]
let closedFirstHalf = array[...middle]
let closedSecondHalf = array[middle...]
/*:
### Бесконечные последовательности

Вы можете использовать односторонний диапазон для конструирования бесконечной последовательности, то есть как более гибкое замещение `enumerated()`, если вы не хотите начинать с нуля:
*/

let letters = ["a","b","c","d"]
let numberedLetters = zip(1..., letters)
Array(numberedLetters)
/*:
 ### Subscripts коллекции Collection
 Если  вы используете односторонние диапазоны для подписки (subscripting) внутри коллекции Collection, то `startIndex` или `endIndex` “заполнят” соответственно пропущенные нижнюю или верхнюю границы.
 
 */
let numbers = [1,2,3,4,5,6,7,8,9,10]
numbers[5...] // вместо numbers[5..<numbers.endIndex]

/*:
 ### Шаблоны соответствия Pattern Matching
 
 Односторонние диапазоны могут использоваться в конструировании шаблонов соответствия, то есть в выражениях `case` в предложении `switch`. Хотя, заметьте, что компилятор не может (пока?) определить, является ли оператор `switch` исчерпывающим, то есть покрывает все случаи.
 */
let value = 5
switch value {
case 1...:
    print("положительное")
case 0:
    print("нуль")
case ..<0:
    print("отрицательное")
default:
    fatalError("несуществующее")
}

/*:
[Содержание](Table%20of%20contents) • [Предыдущая страница](@previous) • [Следующая страница](@next)
 */
